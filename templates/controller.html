<!DOCTYPE html>
<html>
<head>
    <title>VR控制器 - {{ hand|default('未知')|upper }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root {
            /* UWP 设计语言颜色 */
            --primary-color: #0078D7;
            --primary-hover: #1080E0;
            --accent-color: #FFA500;
            --bg-color: #0F0F0F;
            --surface-color: rgba(32, 32, 32, 0.8);
            --glass-color: rgba(32, 32, 32, 0.5);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-color: #FFFFFF;
            --text-secondary: #CCCCCC;
            --button-size: 18vw;
            
            /* 阴影和过渡 */
            --shadow-soft: 0 4px 12px rgba(0, 0, 0, 0.3);
            --shadow-medium: 0 8px 24px rgba(0, 0, 0, 0.4);
            --shadow-glow: 0 0 20px rgba(0, 120, 215, 0.4);
            --transition-fast: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-medium: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* 媒体查询：适配小屏幕设备 */
        @media (max-width: 360px) {
            :root {
                --button-size: 20vw;
            }
        }

        /* 媒体查询：适配大屏幕设备 */
        @media (min-width: 768px) {
            :root {
                --button-size: 15vw;
            }
        }

        /* 媒体查询：横屏适配 */
        @media (orientation: landscape) {
            :root {
                --button-size: 12vh;
            }
            
            body {
                flex-direction: row;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
            background: linear-gradient(135deg, var(--bg-color) 0%, #1a1a1a 100%);
            color: var(--text-color);
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* 玻璃态效果 */
        .gesture-panel,
        .joystick-area,
        .dial-area,
        .slider-area,
        .vr-button,
        .trigger,
        .cube-container,
        .edit-button {
            background: var(--glass-color);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-medium);
        }

        /* 校准提示 */
        .calibration-hint {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 120, 215, 0.9);
            color: white;
            padding: 2vw 4vw;
            border-radius: 1.5vw;
            font-size: 3.5vw;
            text-align: center;
            z-index: 1000;
            box-shadow: var(--shadow-glow);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(0, 120, 215, 0.4); }
            50% { box-shadow: 0 0 30px rgba(0, 120, 215, 0.8); }
            100% { box-shadow: 0 0 20px rgba(0, 120, 215, 0.4); }
        }

        /* 手势面板 */
        .gesture-panel {
            position: absolute;
            {% if hand == 'Right' %}
            right: 18%;
            {% else %}
            left: 18%;
            {% endif %}
            bottom: 8.5%;
            width: 60vw;
            height: 14vw;
            border-radius: 2vw;
            padding: 1.5vw;
            display: flex;
            {% if hand == 'Right' %}
            flex-direction: row-reverse;
            {% else %}
            flex-direction: row;
            {% endif %}
            justify-content: flex-start;
            overflow-x: auto;
            overflow-y: hidden;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .gesture-panel::-webkit-scrollbar {
            display: none;
        }

        .gesture-grid {
            display: flex;
            gap: 1vw;
            height: 100%;
            justify-content: flex-start;
            align-items: center;
            padding: 0 0.5vw;
        }

        .gesture-item {
            width: 12vw;
            height: 12vw;
            background: var(--glass-color);
            border: 1px solid var(--border-color);
            border-radius: 1.5vw;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5vw;
            font-weight: 600;
            color: var(--text-color);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            transition: var(--transition-medium);
            position: relative;
            flex-shrink: 0;
            box-shadow: var(--shadow-soft);
        }

        .gesture-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .gesture-item.active {
            background: rgba(0, 120, 215, 0.4);
            border-color: var(--primary-color);
            box-shadow: var(--shadow-glow);
            transform: scale(0.95);
        }

        /* 摇杆区域 */
        .joystick-area {
            position: absolute;
            {% if hand == 'Right' %}
            right: 27%;
            {% else %}
            left: 27%;
            {% endif %}
            bottom: 30%;
            width: 45vw;
            height: 45vw;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .joystick-thumb {
            width: 12vw;
            height: 12vw;
            background: var(--primary-color);
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: var(--transition-fast);
            box-shadow: var(--shadow-glow);
        }

        .joystick-thumb.active {
            background: #D13438;
            box-shadow: 0 0 20px rgba(209, 52, 56, 0.6);
        }

        /* 旋钮区域 */
        .dial-area {
            position: absolute;
            {% if hand == 'Right' %}
            right: 3%;
            {% else %}
            left: 3%;
            {% endif %}
            top: 28%;
            width: 28vw;
            height: 28vw;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .dial-thumb {
            width: 8vw;
            height: 8vw;
            background: var(--primary-color);
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: var(--transition-fast);
            box-shadow: var(--shadow-glow);
        }

        /* 滑块区域 */
        .slider-area {
            position: absolute;
            {% if hand == 'Right' %}
            right: 13%;
            {% else %}
            left: 13%;
            {% endif %}
            top: 10%;
            width: 8vw;
            height: 28vw;
            border-radius: 4vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        .slider-thumb {
            width: 8vw;
            height: 4vw;
            background: var(--primary-color);
            border-radius: 4vw;
            position: absolute;
            transition: var(--transition-fast);
            touch-action: none;
            box-shadow: var(--shadow-glow);
        }

        /* VR按钮 */
        .vr-button {
            width: var(--button-size);
            height: var(--button-size);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            transition: var(--transition-medium);
            box-shadow: var(--shadow-soft);
        }

        .vr-button:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-medium);
        }

        .vr-button.active {
            background: var(--primary-color);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: var(--shadow-glow);
        }

        /* 按钮标签 */
        .vr-button-label,
        .trigger-label,
        .edit-button-label,
        .cube-face {
            position: absolute;
            color: var(--text-color);
            font-size: 2.5vw;
            font-weight: 600;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
        }

        @media (orientation: landscape) {
            .vr-button-label,
            .trigger-label,
            .edit-button-label,
            .cube-face {
                font-size: 2vh;
            }
        }

        /* 触发器 */
        .trigger {
            width: var(--button-size);
            height: var(--button-size);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-medium);
            position: absolute;
            box-shadow: var(--shadow-soft);
        }

        .trigger:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-medium);
        }

        .trigger.active {
            background: var(--primary-color);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: var(--shadow-glow);
        }

        /* 触发器定位 */
        .trigger {
            {% if hand == 'Right' %}
            right: 6vw;
            {% else %}
            left: 6vw;
            {% endif %}
            bottom: 42%;
            min-width: 44px;
            min-height: 44px;
        }
        
        .grab {
            {% if hand == 'Right' %}
            right: 6vw;
            {% else %}
            left: 6vw;
            {% endif %}
            bottom: 33%;
            min-width: 44px;
            min-height: 44px;
        }

        @media (max-width: 360px) {
            .trigger {
                {% if hand == 'Right' %}
                right: 4vw;
                {% else %}
                left: 4vw;
                {% endif %}
            }
            
            .grab {
                {% if hand == 'Right' %}
                right: 4vw;
                {% else %}
                left: 4vw;
                {% endif %}
            }
        }

        @media (orientation: landscape) {
            .trigger {
                {% if hand == 'Right' %}
                right: 4vh;
                {% else %}
                left: 4vh;
                {% endif %}
                bottom: 50%;
            }
            
            .grab {
                {% if hand == 'Right' %}
                right: 4vh;
                {% else %}
                left: 4vh;
                {% endif %}
                bottom: 35%;
            }
        }

        /* 立方体控制器 */
        {% if hand == 'Right' %}
        .cube-container {
            width: 24vw;
            height: 24vw;
            perspective: 50vw;
            position: absolute;
            right: 38%;
            bottom: 60%;
        }
        {% else %}
        .cube-container {
            width: 24vw;
            height: 24vw;
            perspective: 50vw;
            position: absolute;
            left: 38%;
            bottom: 60%;
        }
        {% endif %}

        .cube {
            width: 100%;
            height: 100%;
            position: absolute;
            transform-style: preserve-3d;
            transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
            transition: transform 0.1s linear;
        }

        .cube-face {
            width: 100%;
            height: 100%;
            background: var(--glass-color);
            border: 2px solid var(--primary-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5vw;
            font-weight: 700;
            box-shadow: var(--shadow-soft);
        }

        .cube-face.front { transform: translateZ(12vw); }
        .cube-face.back { transform: rotateY(180deg) translateZ(12vw); }
        .cube-face.left { transform: rotateY(-90deg) translateZ(12vw); }
        .cube-face.right { transform: rotateY(90deg) translateZ(12vw); }
        .cube-face.top { transform: rotateX(90deg) translateZ(12vw); }
        .cube-face.bottom { transform: rotateX(-90deg) translateZ(12vw); }

        /* 编辑按钮 */
        .edit-button {
            width: 8vw;
            height: 8vw;
            border-radius: 15%;
            background: rgba(255, 165, 0, 0.2);
            border: 1px solid var(--accent-color);
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-medium);
            z-index: 100;
            box-shadow: var(--shadow-soft);
        }

        .edit-button:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-medium);
        }

        .edit-button.active {
            background: rgba(255, 165, 0, 0.4);
            box-shadow: 0 0 20px rgba(255, 165, 0, 0.4);
        }

        .edit-button-label {
            font-size: 1.5vw;
            font-weight: 700;
            color: var(--text-color);
        }

        @media (orientation: landscape) {
            .edit-button-label {
                font-size: 1.5vh;
            }
        }

        .draggable {
            transition: none !important;
            cursor: move;
            touch-action: none;
        }

        /* 按钮布局 */
        {% if hand == 'Right' %}
        .edit-button {
            top: 5%;
            left: 5%;
        }
        #resetBtn {
            top: 5%;
            left: 15%;
        }
        #hapticBtn {
            top: 5%;
            left: 25%;
        }
        #soundBtn {
            top: 5%;
            left: 35%;
        }
        {% else %}
        .edit-button {
            top: 5%;
            right: 5%;
        }
        #resetBtn {
            top: 5%;
            right: 15%;
        }
        #hapticBtn {
            top: 5%;
            right: 25%;
        }
        #soundBtn {
            top: 5%;
            right: 35%;
        }
        {% endif %}
    </style>
</head>
<body>
<div class="edit-button" id="editBtn">
    <div class="edit-button-label">编辑</div>
</div>

<div class="edit-button" id="resetBtn">
    <div class="edit-button-label">重置</div>
</div>

<div class="edit-button" id="hapticBtn">
    <div class="edit-button-label">震动</div>
</div>

<div class="edit-button" id="soundBtn">
    <div class="edit-button-label">声音</div>
</div>


<div class="gesture-panel">
    <div class="gesture-grid">
        {% if hand == 'Right' %}
            {% for gesture in gestures|reverse %}
                <div class="gesture-item"
                     data-fingers="{{ gesture.fingers | tojson | forceescape }}"
                     ontouchstart="handleGestureSelect(this)">
                    {{ gesture.key }}
                </div>
            {% endfor %}
        {% else %}
            {% for gesture in gestures %}
                <div class="gesture-item"
                     data-fingers="{{ gesture.fingers | tojson | forceescape }}"
                     ontouchstart="handleGestureSelect(this)">
                    {{ gesture.key }}
                </div>
            {% endfor %}
        {% endif %}
    </div>
</div>


<div class="slider-area" id="slider-area">
    <div class="slider-thumb" id="slider"></div>
</div>

<div class="dial-area" id="dial-area">
    <div class="dial-thumb" id="dial"></div>
</div>

<!-- 校准按钮在顶部中央 -->
<div class="vr-button" id="calibrate" style="top: 15%; left: 50%; transform: translateX(-50%);">
    <div class="vr-button-label">校准</div>
</div>

<!-- 立方体控制器 -->
<div class="cube-container">
    <div class="cube" id="cube">
        <div class="cube-face front">前</div>
        <div class="cube-face back">后</div>
        <div class="cube-face left">左</div>
        <div class="cube-face right">右</div>
        <div class="cube-face top">上</div>
        <div class="cube-face bottom">下</div>
    </div>
</div>

<!-- Joystick -->
<div class="joystick-area">
    <div class="joystick-thumb" id="joystick"></div>
</div>

<!-- 校准提示 -->
<div class="calibration-hint">请将手机放平，点击校准按钮后移动手机即可使用</div>

<!-- 触发器 -->
<div class="trigger" id="trigger">
    <div class="trigger-label">扳机</div>
</div>
<div class="trigger grab" id="grab">
    <div class="trigger-label">抓取</div>
</div>

<!-- 手柄标识 -->
<div style="position: absolute; top: 5%; left: 50%; transform: translateX(-50%); font-size: 5vw; font-weight: bold; color: var(--primary-color);">
    {% if hand == 'Right' %}
    右手柄
    {% else %}
    左手柄
    {% endif %}
</div>

<!-- Right Hand Layout -->
{% if hand == 'Right' %}
<div class="vr-button" id="system" style="bottom: 15%; right: 60%;">
    <div class="vr-button-label">系统</div>
</div>
<div class="vr-button" id="button1" style="bottom: 15%; right: 40%;">
    <div class="vr-button-label">B</div>
</div>
<div class="vr-button" id="button0" style="bottom: 15%; right: 20%;">
    <div class="vr-button-label">A</div>
</div>

<!-- Left Hand Layout -->
{% else %}
<div class="vr-button" id="button0" style="bottom: 15%; left: 20%;">
    <div class="vr-button-label">X</div>
</div>
<div class="vr-button" id="button1" style="bottom: 15%; left: 40%;">
    <div class="vr-button-label">Y</div>
</div>
<div class="vr-button" id="system" style="bottom: 15%; left: 60%;">
    <div class="vr-button-label">SYS</div>
</div>
{% endif %}

<script>
    const CONFIG = {
        hand: "{{ hand|default('Left') }}",
        sendInterval: "{{ send_interval|default('16') }}",
        deadZone: 0.05
    };

    const serverIp = "{{ server_ip }}";
    const serverPort="{{ server_port }}"
    const websocketUrl = `wss://${serverIp}:${serverPort}`;

    const socket = new WebSocket(websocketUrl);

    let audioContext = null;

    socket.onopen = function() {
        console.log('WebSocket连接已建立');
    };

    socket.onmessage = function(event) {
        try {
            const data = JSON.parse(event.data);
            if (data.type === 'haptic' && data.hand === CONFIG.hand) {
            if (isHapticMode) {
                triggerHapticFeedback(data.duration);
            }
            if (isSoundMode) {
                playVibrationSound(data.duration);
            }
        }
        } catch (error) {
            console.error('解析WebSocket消息失败:', error);
        }
    };
    let isPlaying = false;
   function playVibrationSound(duration = 100) {
       if (isPlaying) {
           console.log('声音正在播放中，请稍候');
           return;
       }
       if (duration < 100 && duration > 0) {
          duration = 100;
       }
       if (!audioContext) return;
       try {
           isPlaying = true;

           const oscillator = audioContext.createOscillator();
           const gainNode = audioContext.createGain();
           oscillator.connect(gainNode);
           gainNode.connect(audioContext.destination);
           oscillator.type = 'sine';
           oscillator.frequency.setValueAtTime(140, audioContext.currentTime);
           gainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
           gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);

           oscillator.start();
           oscillator.stop(audioContext.currentTime + duration / 1000);
           oscillator.onended = () => {
               gainNode.disconnect();
               oscillator.disconnect();
               isPlaying = false;
           };
       } catch (error) {
           console.error('声音播放失败:', error);
           isPlaying = false;
       }
   }

    function triggerHapticFeedback(duration) {
        try {
            if (navigator.vibrate) {
                navigator.vibrate(duration);
            }
        } catch (e) {
            console.warn('震动反馈失败:', e);
        }
    }

    socket.onclose = function() {
        console.log('WebSocket连接已关闭');
        // 可以在这里添加重连逻辑
    };

    socket.onerror = function(error) {
        console.error('WebSocket错误:', error);
    };

    let state = {
        slider: 0,
        sliderClicked: false,
        dial: [0, 0],
        dialClicked: false,
        joystick: [0, 0],
        joystickClicked: false,
        buttons: {
            system: false,
            button0: false,
            button1: false,
            trigger: false,
            grab: false
        },
        fingers:[1, 1, 1, 1, 1]
    };

    let rawQuaternion = { w: 1, x: 0, y: 0, z: 0 };
    let calibQuaternion = { w: 1, x: 0, y: 0, z: 0 };
    let calibratedQuaternion = { w: 1, x: 0, y: 0, z: 0 };

    const cube = document.getElementById('cube');

    let isEditMode = false;
    let isHapticMode = true;
    let isSoundMode = false;
    let selectedElement = null;
    let initialX = 0;
    let initialY = 0;
    let currentX = 0;
    let currentY = 0;
    let positions = {};

    const storageKey = `controllerPositions_${CONFIG.hand}`;

    document.getElementById('editBtn').addEventListener('touchstart', function(e) {
        isEditMode = !isEditMode;
        this.classList.toggle('active', isEditMode);

        document.querySelectorAll('.vr-button, .trigger, .joystick-area, .cube-container, .dial-area, .slider-area, .gesture-panel').forEach(el => {
            el.classList.toggle('draggable', isEditMode);
        });

        if (!isEditMode) {
            localStorage.setItem(storageKey, JSON.stringify(positions));
        }
    });

    // Reset Button functionality
    document.getElementById('resetBtn').addEventListener('touchstart', function() {
        localStorage.removeItem(storageKey);
        window.location.reload(); // Reload the page to reset positions
    });

    document.getElementById('hapticBtn').addEventListener('touchstart', function(e) {
        isHapticMode = !isHapticMode;
        this.classList.toggle('active', isHapticMode);
    });

    document.getElementById('soundBtn').addEventListener('touchstart', function(e) {
        isSoundMode = !isSoundMode;
        this.classList.toggle('active', isSoundMode);
    });


    document.addEventListener('touchstart', function(e) {
        if (!isEditMode) return;
        const newSelected = e.target.closest('.draggable');
        if (!newSelected) return;
        e.preventDefault();

        if (selectedElement && selectedElement !== newSelected) {
            selectedElement.style.transition = '';
            selectedElement.style.boxShadow = '';
            const prevId = selectedElement.id || selectedElement.className.match(/[\w-]+/)[0];
            const prevRect = selectedElement.getBoundingClientRect();
            positions[prevId] = { x: prevRect.left, y: prevRect.top };
        }
        selectedElement = newSelected;
        const rect = selectedElement.getBoundingClientRect();
        initialX = e.touches[0].clientX - rect.left;
        initialY = e.touches[0].clientY - rect.top;
        currentX = rect.left;
        currentY = rect.top;
        selectedElement.style.transition = 'none';
        selectedElement.style.boxShadow = '0 0 15px orange';
    });

    document.addEventListener('touchmove', function(e) {
        if (!isEditMode || !selectedElement) return;

        e.preventDefault();
        const touch = e.touches[0];

        const newX = touch.clientX - initialX;
        const newY = touch.clientY - initialY;

        selectedElement.style.left = `${newX}px`;
        selectedElement.style.top = `${newY}px`;
    });

    document.addEventListener('touchend', function() {
        if (!isEditMode || !selectedElement) return;
        selectedElement.style.transition = '';
        selectedElement.style.boxShadow = '';

        const rect = selectedElement.getBoundingClientRect();
        const id = selectedElement.id || selectedElement.className.match(/[\w-]+/)[0];
        positions[id] = {
            x: rect.left,
            y: rect.top
        };

        selectedElement = null;
    });

    window.addEventListener('load', function() {
        const savedPositions = localStorage.getItem(storageKey);
        if (savedPositions) {
            try {
                positions = JSON.parse(savedPositions);
                Object.entries(positions).forEach(([id, pos]) => {
                    const el = document.getElementById(id) ||
                             document.querySelector(`.${id.split(' ')[0]}`);
                    if (el) {
                        el.style.left = `${pos.x}px`;
                        el.style.top = `${pos.y}px`;
                        el.style.right = 'auto';
                        el.style.bottom = 'auto';
                    }
                });
            } catch (error) {
                console.error('解析保存的位置失败:', error);
                localStorage.removeItem(storageKey);
            }
        }

        document.getElementById('hapticBtn').classList.toggle('active', isHapticMode); // [!code ++]

        const gestureItems = document.querySelectorAll('.gesture-item');
        if (gestureItems.length > 0) {
            let selectedGestureItem = gestureItems[0];
            if (CONFIG.hand=="Right") {
                selectedGestureItem = gestureItems[gestureItems.length - 1];
            }
            handleGestureSelect(selectedGestureItem);
        }
    });

    initJoystick();
    initDial();
    initSlider();
    initButtons();
    initTriggers();
    initCalibrate();
    startTracking();

    function startTracking() {
        window.addEventListener('deviceorientation', event => {
            rawQuaternion = toQuaternion(event.alpha || 0, event.beta || 0, event.gamma || 0);
            calibratedQuaternion = multiplyQuaternions(calibQuaternion, rawQuaternion);
            updateCubeRotation(calibratedQuaternion);
        });

        setInterval(() => {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    hand: CONFIG.hand,
                    quaternion: calibratedQuaternion,
                    ...state
                }));
            }
        }, CONFIG.sendInterval);
    }

    function updateCubeRotation(quaternion) {
        const matrix = quaternionToMatrix(quaternion);
        cube.style.transform = `matrix3d(${matrix.join(',')})`;
    }

    function toQuaternion(alpha, beta, gamma) {
        const degToRad = Math.PI / 180;

        const angles = {
            z: -alpha * degToRad,
            x: -beta * degToRad,
            y: gamma * degToRad
        };

        const cz = Math.cos(angles.z / 2);
        const sz = Math.sin(angles.z / 2);
        const cx = Math.cos(angles.x / 2);
        const sx = Math.sin(angles.x / 2);
        const cy = Math.cos(angles.y / 2);
        const sy = Math.sin(angles.y / 2);

        const qz = { w: cz, x: 0, y: 0, z: sz };
        const qx = { w: cx, x: sx, y: 0, z: 0 };
        const qy = { w: cy, x: 0, y: sy, z: 0 };

        const temp = multiplyQuaternions(qz, qx);
        return multiplyQuaternions(temp, qy);
    }

    function multiplyQuaternions(a, b) {
        return {
            w: a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z,
            x: a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y,
            y: a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x,
            z: a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w
        };
    }

    function quaternionToMatrix(q) {
        const { x, y, z, w } = q;
        const xx = x * x, xy = x * y, xz = x * z,         xw = x * w;
        const yy = y * y, yz = y * z, yw = y * w;
        const zz = z * z, zw = z * w;

        return [
            1 - 2 * (yy + zz), 2 * (xy - zw), 2 * (xz + yw), 0,
            2 * (xy + zw), 1 - 2 * (xx + zz), 2 * (yz - xw), 0,
            2 * (xz - yw), 2 * (yz + xw), 1 - 2 * (xx + yy), 0,
            0, 0, 0, 1
        ];
    }

    function sendState() {
        const message = JSON.stringify({
            hand: CONFIG.hand,
            quaternion: calibratedQuaternion,
            ...state
        })

        // Send the message multiple times to ensure it is received
        for (let i = 0; i < 3; i++) {
            if (socket.readyState === WebSocket.OPEN) {
                socket.send(message);
            }
        }
    }


    function initJoystick() {
        const joystick = document.getElementById('joystick');
        const area = document.querySelector('.joystick-area');
        let touchId = null;

        const updatePosition = (x, y) => {
            const distance = Math.sqrt(x * x + y * y);
            if (distance > 1) {
                x /= distance;
                y /= distance;
            }
            state.joystick = [
                Math.abs(x) > CONFIG.deadZone ? x : 0,
                Math.abs(y) > CONFIG.deadZone ? y : 0
            ];
            joystick.style.transform = `translate(${x * 200}%, ${y * 200}%) translate(-50%, -50%)`;
        };

        area.addEventListener('touchstart', e => {
            if (isEditMode) return;
            if (!touchId) {
                touchId = e.changedTouches[0].identifier;
                updateJoystick(e);
                // sendState();
            }
        });

        area.addEventListener('touchmove', e => {
            if (isEditMode) return;

            if (touchId !== null) {
                updateJoystick(e);
                // sendState();
            }
        });

        area.addEventListener('touchend', () => {
            if (isEditMode) return;
            touchId = null;
            joystick.style.transform = 'translate(-50%, -50%)';
            state.joystick = [0, 0];
            // sendState();
        });

        joystick.addEventListener('dblclick', () => {
            if (isEditMode) return;
            state.joystickClicked = !state.joystickClicked;

            if (state.joystickClicked) {
                joystick.classList.add('active');
            } else {
                joystick.classList.remove('active');
            }
            sendState();
        });

        function updateJoystick(e) {
            const touch = Array.from(e.touches).find(t => t.identifier === touchId);
            if (!touch) return;
            const rect = area.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const x = (touch.clientX - rect.left - centerX) / centerX;
            const y = (touch.clientY - rect.top - centerY) / centerY;
            updatePosition(x, y);
        }
    }
    function initDial() {
        const dial = document.getElementById('dial');
        const area = document.getElementById('dial-area');
        let touchId = null;

        const updatePosition = (x, y) => {
            const distance = Math.sqrt(x * x + y * y);
            if (distance > 1) {
                x /= distance;
                y /= distance;
            }
            state.dial = [
                Math.abs(x) > CONFIG.deadZone ? x : 0,
                Math.abs(y) > CONFIG.deadZone ? y : 0
            ];
            dial.style.transform = `translate(${x * 200}%, ${y * 200}%) translate(-50%, -50%)`;
        };

        area.addEventListener('touchstart', e => {
            if (isEditMode) return;
            if (!touchId) {
                touchId = e.changedTouches[0].identifier;
                updateDialPosition(e);
                // sendState();
            }
        });

        area.addEventListener('touchmove', e => {
            if (isEditMode) return;
            if (touchId !== null) {
                updateDialPosition(e);
                // sendState();
            }
        });

        area.addEventListener('touchend', () => {
            if (isEditMode) return;
            touchId = null;
            dial.style.transform = 'translate(-50%, -50%)';
            state.dial = [0, 0];
            // sendState();
        });
        dial.addEventListener('dblclick', () => {
            if (isEditMode) return;
            state.dialClicked = true;
            sendState();
            state.dialClicked = false;
        });
        function updateDialPosition(e) {
            const touch = Array.from(e.touches).find(t => t.identifier === touchId);
            if (!touch) return;
            const rect = area.getBoundingClientRect();
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const x = (touch.clientX - rect.left - centerX) / centerX;
            const y = (touch.clientY - rect.top - centerY) / centerY;
            updatePosition(x, y);
        }
    }

    function initSlider() {
        const slider = document.getElementById('slider');
        const area = document.getElementById('slider-area');
        let touchId = null;
        let isDragging = false;

        const getCenterPosition = () => {
            const moveRange = area.offsetHeight - slider.offsetHeight;
            return moveRange / 2;
        };

        const resetToCenter = () => {
            slider.style.transition = 'transform 0.1s cubic-bezier(0.25, 0.1, 0.25, 1)';
            slider.style.transform = `translateY(${getCenterPosition()}px)`;
            state.slider = 0;
            sendState();
        };

        resetToCenter();

        const updatePosition = (clientY) => {
            const rect = area.getBoundingClientRect();
            const sliderHeight = slider.offsetHeight;
            const minY = rect.top + sliderHeight/2;
            const maxY = rect.bottom - sliderHeight/2;
            const clampedY = Math.min(Math.max(clientY, minY), maxY);
            const yPosition = (clampedY - minY) / (maxY - minY);
            const value = Number(((yPosition * 2) - 1));
            state.slider = -value;
            const moveRange = rect.height - sliderHeight;
            const translateY = yPosition * moveRange;
            slider.style.transition = 'none';
            slider.style.transform = `translateY(${translateY}px)`;
        };
        area.addEventListener('touchstart', e => {
            if (isEditMode) return;
            if (!touchId) {
                isDragging = true;
                touchId = e.changedTouches[0].identifier;
                updatePosition(e.touches[0].clientY);
                // sendState();
            }
        });
        area.addEventListener('touchmove', e => {
            if (isEditMode) return;
            if (touchId !== null && isDragging) {
                updatePosition(e.touches[0].clientY);
                // sendState();
            }
        });
        slider.addEventListener('dblclick', () => {
            if (isEditMode) return;
            state.sliderClicked = true;
            sendState();
            state.sliderClicked = false;
        });
        const handleTouchEnd = () => {
            if (isEditMode) return;
            if (isDragging) {
                isDragging = false;
                touchId = null;
                resetToCenter();
            }
        };
        area.addEventListener('touchend', handleTouchEnd);
        area.addEventListener('touchcancel', handleTouchEnd);
    }

    function initDoubleClick(elementId, stateKey) {
        const element = document.getElementById(elementId);
        element.addEventListener('dblclick', () => {
            if (isEditMode) return;
            state.buttons[stateKey] = !state.buttons[stateKey];
            if (state.buttons[stateKey]) {
                element.classList.add('active');
            } else {
                element.classList.remove('active');
            }
        });
    }

    function initButtons() {
        document.querySelectorAll('.vr-button').forEach(btn => {
            btn.addEventListener('touchstart', () => {
                if (isEditMode) return;
                btn.classList.add('active');
                state.buttons[btn.id] = true;
                sendState();
            });

            btn.addEventListener('touchend', () => {
                if (isEditMode) return;
                btn.classList.remove('active');
                state.buttons[btn.id] = false;
                sendState();
            });
        });
    }

    function initTriggers() {
        const initTrigger = (id, stateKey) => {
            const trigger = document.getElementById(id);
            trigger.addEventListener('touchstart', () => {
                if (isEditMode) return;
                trigger.classList.add('active');
                state.buttons[stateKey] = true;
                sendState();
            });

            trigger.addEventListener('touchend', () => {
                if (isEditMode) return;
                trigger.classList.remove('active');
                state.buttons[stateKey] = false;
                sendState();
            });
        };

        initTrigger('trigger', 'trigger');
        initTrigger('grab', 'grab');
        initDoubleClick('grab', 'grab');
    }

    function initCalibrate() {
        const calibrateBtn = document.getElementById('calibrate');
        const hint = document.querySelector('.calibration-hint');
        
        // 点击校准后隐藏提示
        calibrateBtn.addEventListener('click', () => {
            if (hint) {
                hint.style.display = 'none';
            }
        });

        async function initAudio() {
            if (!audioContext) {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContext();
                    console.log('音频上下文已初始化');
                } catch (error) {
                    console.error('音频上下文初始化失败:', error);
                }
            }
        }

        async function requestIOSPermissions() {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceMotionEvent.requestPermission();
                    console.log('设备运动权限响应:', response);
                } catch (err) {
                    console.warn('请求设备运动权限错误:', err);
                }
            }

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const response = await DeviceOrientationEvent.requestPermission();
                    console.log('设备方向权限响应:', response);
                } catch (err) {
                    console.warn('请求设备方向权限错误:', err);
                }
            }
        }
        async function requestVibrationPermission() {
            try {
                if (navigator.vibrate && navigator.permissions) {
                    const status = await navigator.permissions.query({ name: 'vibrate' });
                    console.log('震动权限状态:', status.state);
                }
            } catch (e) {
                console.warn('检查震动权限失败:', e);
            }
        }

        calibrateBtn.addEventListener('click', async (e) => {
            if (isEditMode) return;
            e.preventDefault();

            await requestIOSPermissions();
            await requestVibrationPermission();
            await initAudio();
            calibQuaternion = {
                w: rawQuaternion.w,
                x: -rawQuaternion.x,
                y: -rawQuaternion.y,
                z: -rawQuaternion.z
            };

            const NinetyDegreesXQuaternion = {
                w: Math.cos(Math.PI / 4),
                x: Math.sin(Math.PI / 4),
                y: 0,
                z: 0
            };

            calibQuaternion = multiplyQuaternions(NinetyDegreesXQuaternion, calibQuaternion);

            console.log('校准已应用');
        });
    }
    let activeGesture = null;

    function handleGestureSelect(element) {
        if (isEditMode) return;
        document.querySelectorAll('.gesture-item').forEach(item => {
            item.classList.remove('active');
        });

        element.classList.add('active');
        activeGesture = element;

        const fingers = JSON.parse(element.dataset.fingers);
        state.fingers = [fingers[0],fingers[1],fingers[2],fingers[3],fingers[4]];
        sendState();
    }

</script>
</body>
</html>
